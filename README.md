## 2021 Project 1

Εκφώνηση: https://k08.chatzi.org/projects/project1/


### Προσωπικά στοιχεία

__Όνομα__: Anna Gogoula

__Α.Μ.__: sdi1800305


### Documentation
***
Παραδίδω τις ασκήσεις 1, 2, 3, 4, 6.

ΤΟ ΠΑΙΧΝΊΔΙ ΈΧΕΙ ΚΆΠΟΙΑ ΛΑΘΗ!
***
#### Επιπλέον σχόλια για τον κώδικα:
#### Στο __αρχείο modules/state.c__ :
έχω υλοποιήσει τις συναρτήσεις StateInfo state_info(State state) και List state_objects(State state, float x_from, float x_to).

Η συνάρτηση __state_info(State state)__ απλά επιστρέφει τις βασικές πληροφορίες του παιχνιδιού στην κατάσταση state. Χρησιμοποιώντας την διεύθυνση του struct state_info.

Η συνάρτηση __state_objects(State state, float x_from, float x_to)__ επιστρέφει μια λίστα απο τα αντικείμενα του παιχνιδιού, των οποίων η συντεταγμένη x είναι ανάμεσα στο x_from και x_to.
Ελέγχω το vector στο οποίο υπάρχουν μέσα τα αντικείμενα του παιχνιδιού σειριακά. Όταν κάποιο απο αύτα βρίσκεται ανάμεσα στο x_from και x_to, το αντικείμενο αυτό προστήθεται στην λίστα.

Συνεχίζοντας στο ίδιο αρχείο state.c έχει υλοποιηθεί και αρχηκοποιηθεί μια __λίστα state->portal_pairs__ εσωτερικά της συνάρτησης state_create(). 
Δημιουργείται για κάθε πύλη, ένα PortalPair portal και τα δύο Object entrance, exit. Τα οπία παίρνουν τις τιμές τους απο το vector έχοντας την ως portal exit έναν τυχαιο αριθμο. Και προστήθεται στην λίστα το portal.
Ελέγχεται κάθε κόμβος της λίστας ώστε να εντωπιστεί αν υπάρχει σε κάποια άλλη πύλη εισόδου ήδη ζευγάρι με την τύχαια αυτή πύλη εξόδου! Άν υπάρχει ήδη και αυτό δεν είναι το τελευταίο στοιχείο, το οποίο μόλις προστέθηκε στην λίστα, πρέπει το ζευγάρι να πάρει άλλη τιμή εξόδου.

Επίσης υπάρχει και η συνάρτηση __state_update(State state, KeyState keys)__ η οποία ενημερώνει την κατάσταση state του παιχνιδιού μετά την πάροδο 1 frame.
Αρχικά δημιουργούνται 2 Object object τα οποία παίρνουν σειριακά τα αντικείμενα που υπάρχουν στο vector, ανα 2.
Εφόσον το παιχνίδι παίζει:
Τοποθετουμέ τον __χαρακτήρα__ στην αρχή της πίστας και τον μετακινούμε 7 pixels. Μετά ελέγχονται οι περιπτώσεις κατα τις οποίες ο χαρακτήρας κατευθύνεται προς την ίδια κατευθυνση είτε δεξιά είτε αριστερά και είναι πατημένο το αντίστοιχο key, τότε προχωράει 12 pixels.
Εάν όμως ο χαρακτήραας κινείται προς την αντίθετη κατεύθυνση και πατηθεί key που δείχνει προς την άλλη ο χαρακηρας αλλάζει κατευθυνση.
Άν ο χαρακτήρας δεν είναι σε καταάσταση άλματος και πατηθεί το key up μπαίνει σε κατάσταση άλματος και μτακινείται 15 pixels προς τα πάνω.
Ελέγχεται αν έχει φτάσει σε ένα συγκεκριμένο σημείο και ξεκινά η πτώση του, μετακινήται 15 pixels προς τα κάτω.
Αλλιώς συνεχίζεται το άλμα. Η ταχυτητά του εξαρτάται απο το άν είναι πατημενο το key right ή το eft.

Για τις συγκρούσεις των αντικειμένων έχει δημιουργηθεί μία συνάρτηση __objects_conflicts__ η οποία επιστρεέφει true άν υπάρξει κάποια σύγκρουση μεταξύ δύο αντικειμένων.
Επομένως ελέγχονται οι περιπτώσεις όπου ο χαρακτήρας συγκρούεται με κάποιο αντικείμενο εκτός των πυλών, ώστε να σταματήσει το παιχνίδι.
Μετά ελέγχεται η περίπτωση όπου συγκρούεται με μία πύλη.

Στη συνέχεια ελέγχονται οι περιπτώσεις για τους __εχθρούς__. Άν συγκρουστεί με ένα εμπόδιο, αλλάζει κατεύθυνση. Εάν object->type == ENEMY τότε μετακινήται 5 pixels στην κατεύθυνση της κίνησής του. 

Αν ο χαρακτήρας ή ένας εχθρός __συγκρουστεί με μια Πύλη__ A 
ενώ κινείται στην κανονική κατεύθυνση (προς τα δεξιά), τότε μετακινείται στην αντίστοιχη πύλη B στην οποία οδηγεί η Α.
Αν κινείται ανάποδα, τότε η μετακίνηση είναι αντίστροφη,
δηλαδή μετακινείται στην πύλη B η οποία οδηγεί στην A.
Αν ο χαρακτήρας συγκρουστεί με την τελευταία πύλη, τότε προστίθεται μία νίκη και μετακινείται στην αρχή της πίστας.
Αυτό συνεχίζεται μέχρις ότου φτάσουμε στο τελευταίο στοιχείο του vector, οπου περιέχονται τα αντικείμενα. 

Εάν το παιχνιδί έχει σταματήσει και πατηθέι το keys->enter τότε το παιχνίδι ξεκινά απο την αρχή. Άν πατηθεί το πλήκτρο p τότε το μπαίνει σε κατάσταση pause, κατα την διάρκεια του pause όταν πατηθέι το n η κατάσταση ανανεώνεται για 1 frame.

Τέλος υπάρχει η συνάρχτηση __state_destroy(State state)__
είναι αρκετά αποτυχημένη γιάτι δεν μπορούσα να κάνω σωστά τα destroy και τα free.
***
#### Στο αρχείο tests/__state_test.c__ : 
Στην συνάρτηση __test_state_create()__ γίνεται έλεγχος για την θέση του χαρακτήρα και δοκιμές για την συνάρτηση state_objects(). Δοκιμάζοντας 3 διαφορετικές περιπτώσεις ωστε αν εντωπιστούν τα αντικείμενα που βρίστονται σε αυτό το δοκιμαστικό διάστημα.

Στην συνάρτηση __test_state_update()__ ελέγχουμε περιπτώσεις όπου:
* Ο χαρακηρας, με πατημένο το δεξί βέλος, μετακινείται 12 pixels μπροστά.
* Με πατημένο το αριστερό, μετακινείται 12 pixels προς τα πίσω.
* Μπαίνει σε κατάσταση άλματος και ανεβαίνει 15 pixels.
και τη περίπτωση οπου
* Ξεκινά η πτώση του χαρακτήρρα απο το άλμα, με πατημένο το αριστερό ωστε να αλλάξει κατεύθυνση καθώς προσγειώνεται.
* Δεν έχω κάνει κάποιο αντίστοιχο τεστ για την αλλάγη των πυλών και τις συγκρούσεις.

Σε αυτό το σημείο να πώ οτι με τις τελευταίες αλλαγές που έκανα στην state_update, το δεύτερο τέστ δεν δουλεει σωστα :(
***
#### Στο __αρχείο modules/set_utils.c__:
Δημιουργούνται  δύο συναρτήσεις η __set_find_eq_or_greater(Set set, Pointer value)__ και η __set_find_eq_or_smaller(Set set, Pointer value)__.

Η πρώτη συνάρτηση επιστρέφει την τιμή του set που είναι ισοδύναμη με value ή αν δεν υπάρχει, την μικρότερη τιμή του set που είναι μεγαλύτερη του value. Αν δεν υπάρχει καμία τότε επιστρέφει NULL.
Και η δεύτερη συνάρτηση επιστρεέφει την τιμή του set που είναι ισοδύναμη με value ή αν δεν υπάρχει, την μεγαλύτερη τιμή που είναι μικρότερη απο το value. Άν δεν θπάρχει καμία επιστρέφει NULL.

#### Στο __αρχείο tests/set_utils_test.c__: 
Δημιουργείται ένα set απο ακέραιος αριθμούς και ελέγχονται οι περιπτώσεις κατα τις οποίες:
* χρισημοποιόντας την set_find_eq_or_greater:
    1. υπάρχει το στοιχείο στο set.
    2. δεν υπέρχει άρα επιστρέφεται το αμέσως επόμενο.
    3. δεν υπάρχει επόμενο στοιχείο.
* χρισημοποιόντας την set_find_eq_or_smaller:
    1. δεν υπέρχει το στοιχείο άρα επιστρέφεται το αμέσως προηγόυμενο.
    2. δεν υπάρχει προηγόυμενο στοιχείο.
***

#### Στο __αρχείο modules/state_alt.c__:
Έχω __προσπαθήσει__ να δημιουργήσω αυτο που ζητάει η άσκηση 5, με μεγάλη αποτυχια! :)

Στη συνάρτηση __state_create__ η αλλαγή που έχω κάνει σε σχέση με την αντίστοιχη συνάρτηση στο state.c είναι οτι αντί για vector δημιουργείται ένα set (state->objects), το οποίο θα περιέχει τα αντικέιμενα του παιχνιδιού.
Η σκέψη μου ήταν για την δημιουργία του state->portal_pairs, το οποίο περιέχει τα ζευγάρια πυλών να δημιθυργήσω ενα map. ΠΟΥ ΔΕΝ ΈΧΕΙ ΓΊΝΕΙ.

Όπως και τα υπόλοιπα ζητούμενα της άσκησης.
***

#### Στο αρχέιο __modules/interface.c__:
Έχουμε την συνάρτηση __interface_init__ η οποία αρχικοποιεί το interface του παιχνιδιού με τον ίδιο τρόπο που έγινε και στο interface του game_example. Δηλαδή αρχικοποιείται το παπάθυρο και φωρτώνεται η εικόνα του χαρακτήρα.
Υπάρχει η συνάρτηση __interface_close__, κλέινει το interface του παιχνιδιού (με τον ίδιο τρόπο που γίνεται και στο παράδειγμα).

Τέλος έχουμε τη συνάρτηση __interface_draw_frame__ στην οποία σχεδιάζεται ανα ένα frame η τωρινή κατάσταση του παιχνδιού.
Ξεκινόντας απο τη δημιουργία ενός καμβά ώστε να ξεκινήσει το "Drawing" και ξεκινάει η σχεδίασει του χαρακτήρα και των αντικειμένων του παιχνιδιού.
***

### Στο αρχείο __programs/game/game.c__:
Υπάρχει η συνάρτηση __update_and_draw__ η οποία κάνει update το state και δημιουργέι το interface.
Έχουμε και την main συνάρτηση όπου καλείται η συνάρτηση interface_init, δηλαδή αρχεικοποιήται το παιχνίδι. Μετά καλείται η __start_main_loop__ η οποία καλέι συνεχόμενα την update_and_draw μέχρι ο χρήστης να κλείσει το παράθυρο, όπου και καλέιται η interface_close. Δηλαδή κλέινει το interface του παιχνιδιού.
(Έχω κινήθει όπως και στο παράδειγμα που υπήρχε.)
Τέλος έχει δημιουργηθεί και ένα αρχείο __Makefile__ για το παιχνίδι.

ΕΛΠΊΖΩ ΝΑ ΜΗΝ ΉΤΑΝ ΠΟΎ ΧΆΛΙΑ Η ΕΡΓΑΣΊΑ!!!
